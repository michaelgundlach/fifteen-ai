slow is path calc - but what part?

create new info nodes for boards as i go, which point to parents.
if the board already exists, great - it was from a shorter route and created earlier.

generate nodes 5 deep from the root, and keep track of the leaves.
when you choose one step down from the root, ask the leaves to generate kids.
then you have your full knowledge of the 5-deep new tree.

---------

Map Board to
- parent (to find 4-parent)
- 4-descendents (to easily find the leaves to expand to 5-depth)
- distance to start (for posterity - always choose him immediately when found as a leaf unless he's in our ancestry in which case never)

If we were at a node with best-choice [board=C/score=S/depth=5/next-on-path-to-board=N], then we recurse on N and do the following:
# N must know its 4-descendents
# All descendents up to 4-descendents must know their parents and distance to start
RECURSE(N, best-choice=[C/S/D/?]):
- %{N}.4-descendents.each L:
  - make kids for L.  kids.each K:
    - %{K}.parent = L
    - %{K}.distance to start = %{L}.distance + 1
    - (K's 4-parent).4-descendents.prepend(K)
      [possible optimization: only do the above line for the 4-descendents of the 4-parent of the best kid.  But then we need to
       deal with if we find a rejected alternate path later.  Not worth it.]
- Best kid B = min(all kids scores)
- If B's score is perfect:
  - RETURN the full path from B to start node, in reverse.
- If B's score beats S:
  RECURSE(B's 4-parent, [B/B's score/4/?])
- Else if D is > 0:
  RECURSE(C's (D-1)-parent, [C/S/D-1/?])
- Else
  - RETURN the full path from C to start node, with a message that we're stuck in a local maximum.

Initially, we start at some node A.
 - calculate all A's 1-descendents thru 4(not 5)-descendents.
   - for every node, store parent and distance to start.
   - store %{A}.4-descendents.
 - find best scoring board B in all 1-thru-4-descendents of A and create best-choice [B/S/D/?]
 - RECURSE(A, [B/S/some depth/?])
